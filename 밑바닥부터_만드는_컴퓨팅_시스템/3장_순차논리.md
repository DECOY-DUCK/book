## 3.순차 논리

두 챕터에 걸쳐 연산이 가능한 칩을 만들어 버렸다. 하지만 상태를 유지하지는 않는다. 시간이 지나도 데이터를 기억할 수 있는 칩이 필요한다. 바로 `순차 칩 sequential chip`를 만드는 것을 이장의 목표로 한다.

이 장은 더럽게 어렵다. [이곳에서 힌트를 얻을수 있다.](https://nandgame.com/)

### 플립플롭

플립플롭은 클록 신호에 따라 정해진 시점에서의 입력을 샘플하여 출력에 저장하는 동기식 순서 논리 소자이고 래치는 신호에 상관없이 모든 입력을 계속 감시하다 크록에 관계없이 언제든지 출력을 변화시키는 비동기식 순서 논리 소자다.

플립플롭에는 SR플립플롭,JK플립플롭,T플립플롭 등이 있지만 이책에서는 D플립플롭을 구현한다.
조합논리 회로와의 큰 차이점이 피드백루프가 있다는 것이다.(되먹임이라고도 한다.다음 클럭까지 이 상태를 유지한다.) 

앞으로 만들 칩들에 기본으로 탑재될 소자이다 이책에는 구현하지 않지만 
[이곳에서 내부 구조를 파악할수 있다.](https://nandgame.com/)

모든 메모리장치가 플립플롭으로 만들어진 것은 아니다. 오늘날 컴퓨터 설계자가 대안으로 삼을 수 있느 메모리 기술들은 여러가지 가 있으며 성능과 비용을 고려해서 결정한다.

![image](https://user-images.githubusercontent.com/51963264/189170312-dc340ae0-cb07-4767-ba61-32cb98217e76.png)

사실 크게 보면 메모리와 프로그램카운터 구현이 이 장의 목표다. 나머지는 그것들을 구현하기 위한 부품이다.  

### **레지스터**

먼저 1비트 레지스터를 만든다. 1비트 레지스터는 하나의 비트를 저장하도록 설계된 소자이다. 이것을 모아 멀티 비트를 처리하는 레지스트를 만든다.

```
CHIP Bit {
    IN in, load;
    OUT out;

    PARTS:

    Mux(a=i, b=in, sel=load, out=r);
    DFF(in=r, out=i,out = out);
}
```

이걸 이용해서 n비트에 대한 읽기/쓰기가 가능해진다. 

![image](https://user-images.githubusercontent.com/51963264/189216899-cbe2dde1-6105-4e03-a786-0b0b2878c37f.png)

2비트일 경우에는 위와 같이 구현한다. 이걸 참고하면 멀티비트를 쉽게 구현할 수 있다.

```
CHIP Register {
    IN in[16], load;
    OUT out[16];

    PARTS:
    Bit(in=in[0], load=load, out=out[0]);
    Bit(in=in[1], load=load, out=out[1]);
    Bit(in=in[2], load=load, out=out[2]);
    Bit(in=in[3], load=load, out=out[3]);
    Bit(in=in[4], load=load, out=out[4]);
    Bit(in=in[5], load=load, out=out[5]);
    Bit(in=in[6], load=load, out=out[6]);
    Bit(in=in[7], load=load, out=out[7]);
    Bit(in=in[8], load=load, out=out[8]);
    Bit(in=in[9], load=load, out=out[9]);
    Bit(in=in[10], load=load, out=out[10]);
    Bit(in=in[11], load=load, out=out[11]);
    Bit(in=in[12], load=load, out=out[12]);
    Bit(in=in[13], load=load, out=out[13]);
    Bit(in=in[14], load=load, out=out[14]);
    Bit(in=in[15], load=load, out=out[15]);
}
```
이렇게 하면 메모리를 만들기 위한 준비는 끝난다. 다음 메모리 구현은 넘어간다.

### **메모리**   
  
![image](https://user-images.githubusercontent.com/51963264/189173660-70aa352c-238a-4f27-8f7f-e2134123b9bc.png)

책의 설명으로는 바로 와닿지 않았다.   
address[2]인 경우를 구현했을때 이런 회로가 만들어진다. RAM8을 구현하기 전에 참고하면 많은 도움이 된다.

```
CHIP RAM8 {
    IN in[16], load, address[3];
    OUT out[16];

    PARTS:
    DMux8Way(in=load, sel=address, a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);
    Register(in=in, load=a, out=o1);
    Register(in=in, load=b, out=o2);
    Register(in=in, load=c, out=o3);
    Register(in=in, load=d, out=o4);
    Register(in=in, load=e, out=o5);
    Register(in=in, load=f, out=o6);
    Register(in=in, load=g, out=o7);
    Register(in=in, load=h, out=o8);
    Mux8Way16(a=o1, b=o2, c=o3, d=o4, e=o5, f=o6, g=o7, h=o8, sel=address, out=out);
}
```
한번 깨달으면 그다음부터는 응용이라 조금만 생각해보면 된다.

```
HIP RAM64 {
    IN in[16], load, address[6];
    OUT out[16];

    PARTS:
    DMux8Way(in=load, sel=address[3..5], a=a, b=b, c=c, d=d, e=e, f=f, g=g, h=h);
    RAM8(in=in, load=a, address=address[0..2], out=a1);
    RAM8(in=in, load=b, address=address[0..2], out=b1);
    RAM8(in=in, load=c, address=address[0..2], out=c1);
    RAM8(in=in, load=d, address=address[0..2], out=d1);
    RAM8(in=in, load=e, address=address[0..2], out=e1);
    RAM8(in=in, load=f, address=address[0..2], out=f1);
    RAM8(in=in, load=g, address=address[0..2], out=g1);
    RAM8(in=in, load=h, address=address[0..2], out=h1);
    Mux8Way16(a=a1, b=b1, c=c1, d=d1, e=e1, f=f1, g=g1, h=h1, sel=address[3..5], out=out);
}
```

### **계수기**


CPU에 탑재되어 다음에 실행해야 할 프로그램 명령의 주소를 출력하는 기능으로 쓰인다고 한다.

![image](https://user-images.githubusercontent.com/51963264/189216178-7a6627a3-1dea-4c08-988f-c7287180ccdd.png)

**완전히 같지는 않지만** 적당히 응용해서 적용해보면 답을 알수 있다.

```
CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    Mux16(a=o2, b=false, sel=reset, out=inorzero);
    Mux16(a=in, b=incout, sel=inc, out=o1);
    Mux16(a=o1, b=in, sel=load, out=o2);
    Register(in=inorzero, load=true, out=registerout, out=out);
    Inc16(in=registerout, out=incout);
}

```
